<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <meta name="author" content="Igor DejanoviÄ‡">
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>Grammar - textX</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  <link href="../style.css" rel="stylesheet" />
  <link href="../css/version-select.css" rel="stylesheet" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Grammar";
    var mkdocs_page_input_path = "grammar.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
  <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-68681917-1', 'igordejanovic.net');
      ga('send', 'pageview');
  </script>
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> textX</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="..">Home</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">User Guide</span></p>
                <ul class="current">
                    <li class="toctree-l1 current"><a class="reference internal current" href="#">Basics</a>
    <ul class="current">
                <li class="toctree-l2"><a class="reference internal" href="../tutorials/hello_world/">Hello world</a>
                </li>
                <li class="toctree-l2 current"><a class="reference internal current" href="./">Grammar</a>
    <ul class="current">
    <li class="toctree-l3"><a class="reference internal" href="#rules">Rules</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#textx-base-types">textX base types</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#rule-expressions">Rule expressions</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#matches">Matches</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#sequence">Sequence</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#ordered-choice">Ordered choice</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#optional">Optional</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#repetitions">Repetitions</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#assignments">Assignments</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#references">References</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#syntactic-predicates">Syntactic predicates</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#match-suppression">Match suppression</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#repetition-modifiers">Repetition modifiers</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#rule-types">Rule types</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#rule-modifiers">Rule modifiers</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#grammar-comments">Grammar comments</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#language-comments">Language comments</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#grammar-modularization">Grammar modularization</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#inspecting-textx-grammars-programmatically">Inspecting textX grammars programmatically</a>
    </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../metamodel/">Meta-model</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../model/">Model</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../parser_config/">Parser configuration</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../textx_command/">textx command</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../registration/">Registration/Discovery</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../visualization/">Visualization</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../scaffolding/">Project scaffolding</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../howto/">Howtos</a>
                </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="#">Scoping and multi-file</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../scoping/">Scoping</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../rrel/">Reference resolving expression language (RREL)</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../multimetamodel/">Multi meta-model</a>
                </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="#">Errors</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../error_handling/">Error handling</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../debugging/">Debugging</a>
                </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="#">Generators</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../jinja/">Jinja generators</a>
                </li>
    </ul>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Tutorials</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../tutorials/hello_world/">Hello World</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../tutorials/robot/">Robot</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../tutorials/entity/">Entity</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../tutorials/state_machine/">State Machine</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../tutorials/toylanguage/">Toy language compiler</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../tutorials/self-dsl/">self-dsl</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../tutorials/turtle/">Turtle graphics</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Development</span></p>
                <ul>
                    <li class="toctree-l1"><a class="" href="https://github.com/textX/textX/blob/master/CONTRIBUTING.md">Contributing</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../process/">Release process</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">About</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../about/comparison/">Comparison</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="https://github.com/textX/textX/blob/master/LICENSE.txt">License</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">What's new</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../whatsnew/release_1_5/">Release 1.5</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">textX</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
        
          <li>Basics &raquo;</li>
        
      
        
          <li>User Guide &raquo;</li>
        
      
    
    <li>Grammar</li>
    <li class="wy-breadcrumbs-aside">
      
        <a href="https://github.com/textX/textX/edit/master/docs/grammar.md"
          class="icon icon-github"> Edit on GitHub</a>
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="textx-grammar">textX grammar<a class="headerlink" href="#textx-grammar" title="Permanent link">&para;</a></h1>
<p>The language syntax and the meta-model are defined by the textX grammar in the
form of a set of textX rules.</p>
<h2 id="rules">Rules<a class="headerlink" href="#rules" title="Permanent link">&para;</a></h2>
<p>The basic building blocks of the textX language are rules. Each rule is written
in the following form:</p>
<pre><code>Hello:
  'hello' who=ID
;
</code></pre>
<p>This rule is called <code>Hello</code>. After the rule name, there is a colon. The body of
the rule is given as a textX expression, starting at the colon and ending with a
semicolon. This rule tells us that the pattern of <code>Hello</code> objects in input
strings consists of the string literal <code>hello</code>, followed by the ID rule (here ID
is a reference to a built-in rule, more about this in a moment).</p>
<p>These are valid <code>Hello</code> objects:</p>
<pre><code>hello Alice
hello Bob
hello foo1234
</code></pre>
<p>Rule <code>Hello</code> at the same time defines a Python class <code>Hello</code>. When the rule is
recognized in the input stream, an object of this class will get created and the
attribute <code>who</code> will be set to whatever the rule <code>ID</code> has matched after the word
<code>hello</code> (this is specified by the assignment <code>who=ID</code>).</p>
<p>Of course, there are many more rule expressions than those shown in this small
example. In the next section, a detailed description of each textX expression is
given.</p>
<h2 id="textx-base-types">textX base types<a class="headerlink" href="#textx-base-types" title="Permanent link">&para;</a></h2>
<p>In the previous example you have seen an <code>ID</code> rule. This rule is one of the
built-in rules that form the base of textX's type system. Base types/rules are
depicted in the following figure:</p>
<p><img alt="base types" src="../images/base_types.png" /></p>
<ul>
<li><code>ID</code> rule: matches a common identifier consisting of letters, digits
  and underscores. The regex pattern that describe this rule is <code>'[^\d\W]\w*\b'</code>.
  This match will be converted to a Python string.</li>
<li><code>INT</code> rule: matches an integer number. This match will be converted to
  a Python <code>int</code> instance.</li>
<li><code>FLOAT</code> rule: will match a floating point number. This match will be converted
  to a Python <code>float</code> instance ('FLOAT' is a direct subtype of 'BASETYPE'; 
  in order to distinguish floats and ints, 'STRICTFLOAT' was introduced).</li>
<li><code>STRICTFLOAT</code> rule: will match a floating point number. This match will be 
  converted to a Python <code>float</code> instance. A 'STRICTFLOAT' will not match an 'INT' 
  (without "." or "e|E"). A 'NUMBER' is either a 'STRICTFLOAT' or an 'INT', 
  and will, thus, be converted to a float or an int, respectively.</li>
<li><code>BOOL</code> rule: matches the words <code>true</code> or <code>false</code>. This match
  will be converted to a Python <code>bool</code> instance.</li>
<li><code>STRING</code> rule: matches a quoted string. This match will be converted
  to a Python <code>str</code> instance.</li>
</ul>
<p>textX base types are automatically converted to python types during object
instantiation.
See <a href="../metamodel/#auto-initialization-of-attributes">auto-initialization</a> for
more information.</p>
<h2 id="rule-expressions">Rule expressions<a class="headerlink" href="#rule-expressions" title="Permanent link">&para;</a></h2>
<p>Rule expressions represent the body of a rule. They is specified using basic
expressions and operators.</p>
<p>The basic expressions are:</p>
<ul>
<li><a href="#matches">Matches</a><ul>
<li>String match (<code>'...'</code> or <code>"..."</code>)</li>
<li>Regex match (<code>/.../</code>)</li>
</ul>
</li>
<li><a href="#sequence">Sequence</a></li>
<li><a href="#ordered-choice">Ordered choice</a> (<code>|</code>)</li>
<li><a href="#optional">Optional</a> (<code>?</code>)</li>
<li><a href="#repetitions">Repetitions</a><ul>
<li>Zero or more (<code>*</code>)</li>
<li>One or more (<code>+</code>)</li>
<li>Unordered group (<code>#</code>)</li>
</ul>
</li>
<li><a href="#references">References</a><ul>
<li>Match reference</li>
<li>Link reference (<code>[..]</code>)</li>
</ul>
</li>
<li><a href="#assignments">Assignments</a><ul>
<li>Plain (<code>=</code>)</li>
<li>Boolean (<code>?=</code>)</li>
<li>Zero or more (<code>*=</code>)</li>
<li>One or more (<code>+=</code>)</li>
</ul>
</li>
<li><a href="#syntactic-predicates">Syntactic predicates</a><ul>
<li>Not (<code>!</code>) - negative lookahead</li>
<li>And (<code>&amp;</code>) - positive lookahead</li>
</ul>
</li>
<li><a href="#match-suppression">Match suppression</a></li>
</ul>
<h3 id="matches">Matches<a class="headerlink" href="#matches" title="Permanent link">&para;</a></h3>
<p>Match expressions are, besides base type rules, the expressions at the lowest
level. They are the basic building blocks for more complex expressions. These
expressions will consume input on success.</p>
<p>There are two types of match expressions:</p>
<ul>
<li>
<p><strong>String match</strong> - is written as a single quoted string. It will match a literal
  string on the input.</p>
<p>Here are a few examples of string matches:</p>
<pre><code>'blue'
'zero'
'person'
</code></pre>
</li>
<li>
<p><strong>Regex match</strong> - uses regular expression defined inside <code>/ /</code> to match the
  input. Therefore, it defines a whole class of strings that can be matched.
  Internally a python <code>re</code> module is used.</p>
<p>Here are few example of regex matches:</p>
<pre><code>/\d*/
/\d{3,4}-\d{3}/
/[-\w]*\b/
/[^}]*/
</code></pre>
<p>For more information on Regular Expression in Python see <a href="https://docs.python.org/3/howto/regex.html">Regular Expression
HOWTO</a>.</p>
<p>When the metamodel has the option <code>use_regexp_group</code> set to <code>True</code>, then a
regular expression with exactly one group is replaced by the group. This can
be used to define multiline strings to be stored in the model without the
surrounding limiters:</p>
<pre><code>  Model: 'data' '=' data=/(?ms)\"{3}(.*?)\"{3}/;
</code></pre>
<p>An example model could be</p>
<pre><code>  data = """
  This is a multiline
  text!
  """
</code></pre>
<p>When creating a metamodel with this grammar and the option
<code>use_regexp_group</code> enabled, a multiline string delimited with <code>"""</code> is
accepted: <code>(?ms)</code> activates the multiline option and the <em>dot matches
everything</em> option. <code>\"{3}</code> matches the delimited <code>"""</code>. The pattern
<code>"(.*?)</code> is a non-greedy variant of <em>get anything</em>.</p>
<pre><code>  metamodel = metamodel_from_str(grammar, use_regexp_group=True)
</code></pre>
</li>
</ul>
<h3 id="sequence">Sequence<a class="headerlink" href="#sequence" title="Permanent link">&para;</a></h3>
<p>Sequence is a textX expression that is given by just writing contained
sub-expressions one after another. For example,the following rule:</p>
<pre><code>Colors:
  "red" "green" "blue"
;
</code></pre>
<p>is defined as a sequence consisting of three string matches (<code>red</code> <code>green</code> and
<code>blue</code>). Contained expressions will be matched in the exact order they are
given. If some of the expressions do not match, the sequence as a whole will
fail. The above rule defined by the sequence will match only the following
string:</p>
<pre><code>red green blue
</code></pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If whitespace skipping is enabled (it is by default), arbitrary whitespaces
can occur between matched words.</p>
</div>
<h3 id="ordered-choice">Ordered choice<a class="headerlink" href="#ordered-choice" title="Permanent link">&para;</a></h3>
<p>Ordered choice is given as a set of expression separated by the<code>|</code> operator.
This operator will try to match contained expression from left to right and the
first match that succeeds will be used.</p>
<p>Example:</p>
<pre><code>Color:
  "red" | "green" | "blue"
;
</code></pre>
<p>This will match either <code>red</code> or <code>green</code> or <code>blue</code> and the parser will try to
match the expressions in that order.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In most classic parsing technologies an unordered match (alternative) is used.
This may lead to ambiguous grammars where multiple parse tree may exist for
the same input string.</p>
</div>
<p>Underlying parsing technology of textX
is <a href="https://github.com/textX/Arpeggio">Arpeggio</a> which is a parser based
on PEG grammars and thus the <code>|</code> operator directly translates to Arpeggio's PEG
ordered choice. Using ordered choice yields unambiguous parsing. If the text
parses there is only one possible parse tree.</p>
<h3 id="optional">Optional<a class="headerlink" href="#optional" title="Permanent link">&para;</a></h3>
<p><code>Optional</code> is an expression that will match the contained expression if that is
possible, but will not fail otherwise. Thus, optional expression always
succeeds.</p>
<p>Example:</p>
<pre><code>MoveUp:
  'up' INT?
;
</code></pre>
<p><code>INT</code> match is optional in this example. This means that the <code>up</code> keyword is
required, but the following integer may or may not be found.</p>
<p>Following lines will match:</p>
<pre><code>up 45
up 1
up
</code></pre>
<p>Optional expressions can be more complex. For example:</p>
<pre><code>MoveUp:
  'up' ( INT | FLOAT )?
</code></pre>
<p>Now, an ordered choice in the parentheses is optional.</p>
<h3 id="repetitions">Repetitions<a class="headerlink" href="#repetitions" title="Permanent link">&para;</a></h3>
<ul>
<li>
<p><strong>Zero or more</strong> repetition is specified by the <code>*</code> operator and will match
  the contained expression zero or more times. Here is an example:</p>
<pre><code>Colors:
  ("red"|"green"|"blue")*
;
</code></pre>
<p>In this example <em>zero or more</em> repetition is applied on the <em>ordered
choice</em>. In each repeated match one color will be matched, trying from left
to right. Thus, <code>Colors</code> rule will match color as many times as possible,
but will not fail if no color exists in the input string. The following
would be matched by the <code>Colors</code> rule:</p>
<pre><code>red blue green
</code></pre>
<p>but also:</p>
<pre><code>red blue blue red red green
</code></pre>
<p>or an empty string.</p>
</li>
<li>
<p><strong>One or more</strong> repetition is specified by <code>+</code> operator and will match the
  contained expression one or more times. Thus, everything that is written for
  <strong>zero or more</strong> applies here except that at least one match must be found for
  this expression to succeed. Here is an above example modified to match at
  least one color:</p>
<pre><code>Colors:
  ("red"|"green"|"blue")+
;
</code></pre>
</li>
<li>
<p><strong>Unordered group</strong> is a special kind of a sequence. Syntactically it is
  similar to a repetition. It is specified by the <code>#</code> operator and must be
  applied to sequences. This operator will match each element of the sequence in
  an arbitrary order:</p>
<pre><code>Colors:
  ("red" "green" "blue")#
;
</code></pre>
<p>For the previous example all following lines are valid:</p>
<pre><code>red blue green
red green blue
blue green red
...
</code></pre>
<p>But, the following lines are not valid:</p>
<pre><code>red blue red green
blue green
</code></pre>
<p>Consider this example:</p>
<pre><code>Modifier: 
    (static?='static' final?='final' visibility=Visibility)#
;

Visibility:
    'public' | 'private' | 'protected';
</code></pre>
<p>We want to provide modifiers to the type declarations in our language.
Furthermore, we want modifiers to be written in any order.</p>
<p>The following lines will match (thanks to <code>?=</code> operator, only visibility
must be specified):</p>
<pre><code>public
public static
final protected static
...
</code></pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Unordered group may also have
<a href="#repetition-modifiers">repetition modifiers</a> defined.</p>
</div>
</li>
</ul>
<h3 id="assignments">Assignments<a class="headerlink" href="#assignments" title="Permanent link">&para;</a></h3>
<p>Assignments are used as a part of the meta-model deduction process. Each
assignment will result in an attribute of the meta-class created by the rule.</p>
<p>Each assignment consists of the LHS (left-hand side) and the RHS (right-hand
side). The LHS is always a name of the meta-class attribute while the RHS can be
a reference to other rules (either a match or a link reference) or a simple
match (string or regex match). For example:</p>
<pre><code>Person:
  name=Name ',' surename=Surename ',' age=INT ',' height=INT ';'
;
</code></pre>
<p>The <code>Name</code> and <code>Surename</code> rules referenced in the RHS of the first two
assignments are not given in this example.</p>
<p>This example describes the rule and meta-class <code>Person</code>, that will parse and
instantiate the <code>Person</code> objects with  these four attributes:</p>
<ul>
<li><code>name</code> - which will use the rule <code>Name</code> to match the input, it 
  will be a reference to the instance of the <code>Name</code> class,</li>
<li><code>surename</code> - will use <code>Surename</code> rule to match the input,</li>
<li><code>age</code> - will use the built-in type <code>INT</code> to match a number from the
  input string. <code>age</code> will be converted to the python <code>int</code> type.</li>
<li><code>height</code> - the same as <code>age</code>, but the matched number will be
  assigned to the <code>height</code> attribute of the <code>Person</code> instance.</li>
</ul>
<p>Notice the comma as the separator between matches and the semicolon match at the
end of the rule. Those matches must be found in the input but the matched
strings will be discarded. They represent a syntactic noise.</p>
<p>If the RHS is one of textX BASETYPEs, then the matched string will be converted
to some of the plain python types (e.g. <code>int</code>, <code>string</code>, <code>boolean</code>).</p>
<p>If the RHS is a string or regex match like in this example:</p>
<pre><code>Color:
  color=/\w+/
;
</code></pre>
<p>then the attribute given by the LHS will be set as the string matched by the RHS
regular expression or string.</p>
<p>If the RHS is a reference to some other rule, then the attribute given by the
LHS will be set to refer to the object created by the RHS rule.</p>
<p>Following strings are matched by the <code>Person</code> rule from above:</p>
<pre><code>Petar, Petrovic, 27, 185;
John, Doe, 34, 178;
</code></pre>
<p>There are four types of assignments:</p>
<ul>
<li>
<p><strong>Plain assignment</strong> (<code>=</code>) will match its RHS once and assign what is
  matched to the attribute given by the LHS. The above example uses plain
  assignments.</p>
<p>Examples:</p>
<pre><code>a=INT
b=FLOAT
c=/[a-Z0-9]+/
dir=Direction
</code></pre>
</li>
<li>
<p><strong>Boolean assignment</strong> (<code>?=</code>) will set the attribute to <code>True</code> if
  the RHS match succeeds and to <code>False</code> otherwise.</p>
<p>Examples::</p>
<pre><code>cold ?= 'cold'
number_given ?= INT
</code></pre>
</li>
<li>
<p><strong>Zero or more assignment</strong> (<code>*=</code>) - LHS attribute will be a <code>list</code>. This
  assignment will keep matching the RHS as long as the match succeeds and each
  matched object will be appended to the attribute. If no match succeeds, the
  attribute will be an empty list.</p>
<p>Examples::</p>
<pre><code>commands*=Command
numbers*=INT
</code></pre>
</li>
<li>
<p><strong>One or more assignment</strong> (<code>+=</code>) - same as the previous assignment, but it must match the RHS
  at least once. If no match succeeds, this assignment does not succeed.</p>
</li>
</ul>
<h4 id="multiple-assignment-to-the-same-attribute">Multiple assignment to the same attribute<a class="headerlink" href="#multiple-assignment-to-the-same-attribute" title="Permanent link">&para;</a></h4>
<p>textX allows for multiple assignments to the same attribute. For example:</p>
<pre><code>  MyRule:
      a=INT b=FLOAT a*=ID
  ;
</code></pre>
<p>Here <code>a</code> attribute will always be a Python list. The type of <code>a</code> will be
<code>OBJECT</code> as the two assignments have declared different types for <code>a</code> (<code>INT</code> and
<code>ID</code>).</p>
<p>Consider this example:</p>
<pre><code>  Method:
      'func(' (params+=Parameter[','])? ')'
  ;
  Parameter:
      type=ID name=ID | name=ID
  ;
</code></pre>
<p>In <code>Parameter</code> rule, the <code>name</code> attribute assignments are part of different
ordered choice alternatives and thus name will never have more than one value
and thus should not be a list. The type of <code>name</code> is consistent in both
assignments so it will be <code>ID</code>.</p>
<p>The rule of the thumb for multiple assignments is that if there is no
possibility for an attribute to collect more than one value during parsing it
will be a single value object, otherwise it will be a list.</p>
<h3 id="references">References<a class="headerlink" href="#references" title="Permanent link">&para;</a></h3>
<p>Rules can reference each other. References are usually used as a RHS of the
assignments. There are two types of rule references:</p>
<ul>
<li>
<p><strong>Match rule reference</strong> - will <em>call</em> another rule. When instance of the called
  rule is created, it will be assigned to the attribute on the LHS. We say that the
  referred object is contained inside the referring object (i.e. they form a
  <a href="../metamodel/#parent-child-relationships">parent-child relationship</a>).</p>
<p>Example::</p>
<pre><code>Structure:
  'structure' '{'
    elements*=StructureElement
  '}'
;
</code></pre>
<p><code>StructureElement</code> will be matched zero or more times. With each match, a new
instance of the <code>StructureElement</code> will be created and appended to the <code>elements</code>
python list. A <code>parent</code> attribute of each <code>StructureElement</code> will be set to
the containing <code>Structure</code>.</p>
</li>
<li>
<p><strong>Link rule reference</strong> - will match an identifier of some class object at the
  given place and convert that identifier to a python reference to the target
  object. This reference resolving is done automatically by textX. By default, a
  <code>name</code> attribute is used as the identifier of the object. Currently, there is
  no automatic support for namespaces in textX. All objects of the same class
  are in a single namespace.</p>
<p>Example:</p>
<pre><code>ScreenType:
  'screen' name=ID "{"
  '}'
;

ScreenInstance:
  'screen' type=[ScreenType]
;
</code></pre>
<p>The <code>type</code> attribute is a link to the <code>ScreenType</code> object. This is a valid
usage:</p>
<pre><code>// This is a definition of the ScreenType object
screen Introduction {

}

// And this is a reference link to the ScreenType object defined above
// ScreenInstance instance
screen Introduction
</code></pre>
<p><code>Introduction</code> will be matched, the <code>ScreenType</code> object with that name will
be found and the <code>type</code> attribute of <code>ScreenInstance</code> instance will be set to
it.</p>
<p><code>ID</code> rule is used by default to match the link identifier. If you want to change
that, you can use the following syntax:</p>
<pre><code>ScreenInstance:
  'screen' type=[ScreenType|WORD]
;
</code></pre>
<p>Here, instead of <code>ID</code> a <code>WORD</code> rule is used to match the object's identifier.</p>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Attributes with <code>name</code> names are used for reference auto-resolving. A dict
lookup is used, thus they must be of a hashable type. See 
issues <a href="https://github.com/textX/textX/issues/40">#40</a> and 
<a href="https://github.com/textX/textX/issues/266">#266</a>.</p>
<p>A usual error is to match the name in this fashion:</p>
<pre><code>MyObj: name+=ID['.'];
</code></pre>
<p>Here, <code>name</code> will be a list of strings that are separated by dot and that
will not work as the name must be hashable. The best way to implement this 
and make <code>name</code> hashable is:</p>
<pre><code>MyObj: name=FQN;
FQN: ID+['.'];
</code></pre>
<p>Now, <code>name</code> will be the string returned by the <code>FQN</code> match rule.</p>
</div>
<h3 id="syntactic-predicates">Syntactic predicates<a class="headerlink" href="#syntactic-predicates" title="Permanent link">&para;</a></h3>
<p>Syntactic predicates are operators that are used to implement lookahead. The
lookahead is used to do parsing decision based on the part of the input ahead of
the current position. Syntactic predicates are written as a prefix of some textX
rule expression. The rule expression will be used to match input ahead of the
current location in the input string. It will either fail or succeed but will
never consume any input.</p>
<p>There are two type of syntactic predicates:</p>
<ul>
<li>
<p><strong>Not - negative lookahead</strong> (<code>!</code>) - will succeed if the current input doesn't
  match the expression given after the <code>!</code> operator.</p>
<p>Example problem:</p>
<pre><code>Expression: Let | ID | NUMBER;
Let:
    'let'
        expr+=Expression
    'end'
;
</code></pre>
<p>In this example we have nested expressions built with indirectly recurssive
<code>Let</code> rule. The problem is that the <code>ID</code> rule from <code>Expression</code> will match
keyword <code>end</code> and thus will consume end of <code>Let</code> rule, so the parser will
hit EOF without completing any <code>Let</code> rules. To fix this, we can specify that
<code>ID</code> will match any identifier except keywords <code>let</code> and <code>end</code> like this:</p>
<pre><code>Expression: Let | MyID | NUMBER;
Let:
    'let'
        expr+=Expression
    'end'
;
Keyword: 'let' | 'end';
MyID: !Keyword ID;
</code></pre>
<p>Now, <code>MyID</code> will match <code>ID</code> only if it is not a keyword.</p>
</li>
<li>
<p><strong>And - positive lookahead</strong> (<code>&amp;</code>) - will succeed if the current input starts
  with the string matched by the expression given after the <code>&amp;</code> operator.</p>
<p>Example:</p>
<pre><code>Model:
    elements+=Element
;
Element:
    AbeforeB | A | B
;
AbeforeB: 
    a='a' &amp;'b'      // this succeeds only if 'b' follows 'a'
;
A: a='a';
B: a='b';
</code></pre>
<p>Given the input string <code>a a a b</code> first two <code>a</code> chars will be matched by the
rule <code>A</code>, but the third <code>a</code> will be matched by the rule <code>AbeforeB</code>.  So,
even when <code>AbeforeB</code> matches only <code>a</code> and is tried before any other match,
it will not succeed for the first two <code>a</code> chars because they are not
followed by <code>b</code>.</p>
</li>
</ul>
<h3 id="match-suppression">Match suppression<a class="headerlink" href="#match-suppression" title="Permanent link">&para;</a></h3>
<p>Sometimes it is necessary to define match rules that should return only parts of
the match. For that we use match the suppression operator (<code>-</code>) after the
expression you want to suppress.</p>
<p>For example:</p>
<pre><code>FullyQualifiedID[noskipws]:
    /\s*/-
    QuotedID+['.']
    /\s*/-
;
QuotedID:
    '"'?- ID '"'?-
;
</code></pre>
<p>Because we use <code>noskipws</code> rule modifier, <code>FullyQualifiedID</code> does not skip
whitespaces automatically. Thus, we have to match whitespaces ourself, but we
don't want those whitespaces in the resulting string. You might wonder why we
are using <code>noskipws</code>. It is because we do not want whitespaces in between each
<code>QuotedID</code> match. So, for example, <code>first. second</code> shouldn't match but
<code>first.second</code> should.</p>
<p>In the rule <code>FullyQualifiedID</code> we are suppressing whitespace matches <code>/\s*/-</code>.
We also state in <code>QuotedID</code> that there are optional quotation marks around each
ID, but we don't want those either <code>'"'?-</code>.</p>
<p>Given this input:</p>
<pre><code>first."second".third."fourth"
</code></pre>
<p><code>FullyQualifiedID</code> will return:</p>
<pre><code>first.second.third.fourth
</code></pre>
<h2 id="repetition-modifiers">Repetition modifiers<a class="headerlink" href="#repetition-modifiers" title="Permanent link">&para;</a></h2>
<p>Repetition modifiers are used for the modification of the repetition expressions
(<code>*</code>, <code>+</code>, <code>#</code>, <code>*=</code>, <code>+=</code>). They are specified in brackets <code>[ ]</code>. If there are
more modifiers, they are separated by a comma.</p>
<p>Currently, there are two modifiers defined:</p>
<ul>
<li>
<p><strong>Separator modifier</strong> - is used to define separator on multiple matches.
  Separator is a simple match (string match or regex match).</p>
<p>Example:</p>
<pre><code>numbers*=INT[',']
</code></pre>
<p>Here, a separator string match is defined (<code>','</code>). This will match zero
or more integers separated by commas.</p>
<pre><code>45, 47, 3, 78
</code></pre>
<p>A regex can also be specified as a separator.</p>
<pre><code>fields += ID[/;|,|:/]
</code></pre>
<p>This will match IDs separated by either <code>;</code> or <code>,</code> or <code>:</code>.</p>
<pre><code>first, second; third, fourth: fifth
</code></pre>
</li>
<li>
<p><strong>End-of-line terminate modifier</strong> (<code>eolterm</code>) - used to terminate repetition
  on end-of-line. By default the repetition match will span lines. When this
  modifier is specified, repetition will work inside the current line only.</p>
<p>Example:</p>
<pre><code>STRING*[',', eolterm]
</code></pre>
<p>Here we have a separator as well as the <code>eolterm</code> defined. This will match
zero or more strings separated by commas inside one line.</p>
<pre><code>"first", "second", "third"
"fourth"
</code></pre>
<p>If we run the example expression once on this string, it will match the
first line only. <code>"fourth"</code> in the second line will not be matched.</p>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Be aware that when <code>eolterm</code> modifier is used, its effect starts from the
previous match. For example:</p>
<pre><code>Conditions:
  'conditions' '{'
    varNames+=WORD[eolterm]    // match var names until end of line
  '}'
</code></pre>
<p>In this example <code>varNames</code> must be matched in the same line as
<code>conditions {</code> because <code>eolterm</code> effect start immediately.
In this example we wanted to give the user the freedom to specify var names on
the next line, even to put some empty lines if he/she wishes. In order to do
that, we should modify the example like this::</p>
<pre><code>Conditions:
  'conditions' '{'
    /\s*/
    varNames+=WORD[eolterm]    // match var names until end of line
  '}'
</code></pre>
<p>Regex match <code>/\s*/</code> will collect whitespaces (spaces and new-lines)
before the <code>WORD</code> match begins. Afterwards, repeated matches will work
inside one line only.</p>
</div>
<h2 id="rule-types">Rule types<a class="headerlink" href="#rule-types" title="Permanent link">&para;</a></h2>
<p>There are three kinds of rules in textX:</p>
<ul>
<li>Common rules (or just rules)</li>
<li>Abstract rules</li>
<li>Match rules</li>
</ul>
<p><strong>Common rules</strong> are rules that contain at least one assignment, i.e., they
have attributes defined. For example:</p>
<pre><code>InitialCommand:
  'initial' x=INT ',' y=INT
;
</code></pre>
<p>This rule has two defined attributes: <code>x</code> and <code>y</code>.</p>
<p><strong>Abstract rules</strong> are rules that have no assignments and reference at least one
abstract or common rule. They are usually given as an ordered choice of other
rules and they are used to generalize other rules. For example:</p>
<pre><code>Program:
  'begin'
    commands*=Command
  'end'
;

Command:
  MoveCommand | InitialCommand
;
</code></pre>
<p>In this example, Python objects in the <code>commands</code> list will either contain
instances of <code>MoveCommand</code> or <code>InitialCommand</code>. <code>Command</code> rule is abstract. A
meta-class of this rule will never be instantiated. Abstract rule can also be
used in link rule references:</p>
<pre><code>ListOfCommands:
  commands*=[Command][',']
;
</code></pre>
<p>Abstract rules may reference match rules and base types. For example:</p>
<pre><code>Value:
    STRING | FLOAT | BOOL | Object | Array | "null"
;
</code></pre>
<p>In this example, the base types as well as the string match <code>"null"</code> are all
match rules, but <code>Object</code> and <code>Array</code> are common rules and therefore <code>Value</code> is
abstract.</p>
<p>Abstract rules can be a complex mix of rule references and match expressions as
long as there is at least one abstract or common reference. For example:</p>
<pre><code>Value:
  'id' /\d+-\d+/ | FLOAT | Object
;
</code></pre>
<p>A rule with a single reference to an abstract or common rule is also abstract:</p>
<pre><code>Value:
  OtherRule
;
</code></pre>
<p>Abstract rules can have multiple references in a single alternative with the
following rules:</p>
<ul>
<li>If all rule references in a single alternative are match rules the result will
  be a concatenation of all match rule results,</li>
<li>If there is a common rule reference than it would be the result and all
  surrounding match rules are used only for parsing</li>
<li>If there are multiple common rules than the first will be used as a result and
  the rest only for parsing</li>
</ul>
<p>For example:</p>
<pre><code>Model: STRING | ID | '#' Rule1 Sufix;  // abstract rule
Rule1: a=INT;  // common rule
Prefix: '#';
Sufix: ID | SomeOtherSufix;
SomeOtherSufix: '--' '#';
</code></pre>
<p>In this example matching <code># 42 -- #</code> at input would yield and instance of
<code>Rule1</code> with attribute <code>a</code> set to integer <code>42</code>. This comes from a third
alternative <code>'#' Rule1 Sufix</code> that succeeds and the <code>#</code> and <code>Sufix</code> would be
used just for parsing and the result would be discarded.</p>
<p>Another example:</p>
<pre><code>Model: (STRING | ID | '#' Rule1) Sufix;
Rule1: a=INT; // common rule
Sufix: '--';
</code></pre>
<p>This is also abstract rule as we are referencing <code>Rule1</code> which is a common rule
and we have no assignments. Matching <code># 42 --</code> as input will give an instance of
<code>Rule1</code> with attribute <code>a</code> set to integer <code>42</code>.</p>
<p>In this example:</p>
<pre><code>Model: STRING|Rule1|ID|Prefix INT Sufix;
Rule1: a='a';  // a common rule
Prefix: '#';
Sufix: '--';
</code></pre>
<p>we see that input <code># 42 --</code> would be recognized by the last alternative and the
result will be string <code>#42--</code>, i.e. all match rule results would be concatenated.
But if we give <code>a</code> as input than the result will be an instance of <code>Rule1</code> with
attribute <code>a</code> set to string <code>'a'</code>.</p>
<p>In the following example we see what happens if we have multiple common rule references:</p>
<pre><code>Model: STRING|Rule1|ID|Prefix Rule1 Sufix Rule2;  // Reference both Rule1 and Rule2
Rule1: a=INT; // common rule
Rule2: a=STRING; // common rule
Prefix: '#';
Sufix: '--';
</code></pre>
<p>For input <code># 42 -- "some string"</code> the model will be an instance of <code>Rule1</code> with
attribute <code>a</code> set to <code>42</code> as it is the first common rule reference in the last
alternative (the one that succeeds) but <code>Rule2</code>, despite being discarded, must
also be satisfied during parsing or syntax error would be produced.</p>
<p><strong>Match rules</strong> are rules that have no assignments either direct or indirect,
i.e. all referenced rules are match rules too. They are usually used to specify
enumerated values or some complex string matches that can't be done with regular
expressions.</p>
<p>Examples:</p>
<pre><code>Widget:
  "edit"|"combo"|"checkbox"|"togglebutton"
;

Name:
  STRING|/(\w|\+|-)+/
;

Value:
  /(\w|\+|-)+/ | FLOAT | INT
;
</code></pre>
<p>These rules can be used in match references only (i.e., you can't link to these
rules as they don't exists as objects), and they produce objects of the base
python types (<code>str</code>, <code>int</code>, <code>bool</code>, <code>float</code>).</p>
<p>All base type rules (e.g., <code>INT</code>, <code>STRING</code>, <code>BASETYPE</code>) are match rules.</p>
<h2 id="rule-modifiers">Rule modifiers<a class="headerlink" href="#rule-modifiers" title="Permanent link">&para;</a></h2>
<p>Rule modifiers are used for the modification of the rule's expression. They are
specified in brackets (<code>[ ]</code>) at the beginning of the rule's definition after
the rule's name. Currently, they are used to alter parser configuration for
whitespace handling on the rule level.</p>
<p>Rule modifiers act on the current rule and all rules referenced inside the rule 
(recursively): unless a refrenced rule has an explicit rule modifier, the currently
active modifier state is propagated to referenced rules.</p>
<p>There are two rule modifiers at the moment:</p>
<ul>
<li>
<p><strong>skipws, noskipws</strong> - are used to enable/disable whitespace skipping during
  parsing. This will change the global parser's <code>skipws</code> setting given during
  the meta-model instantiation.</p>
<p>Example:</p>
<pre><code>Rule:
    'entity' name=ID /\s*/ call=Rule2;
Rule2[noskipws]:
    'first' 'second';
</code></pre>
<p>In this example <code>Rule</code> rule will use default parser behaviour set during the
meta-model instantiation, while <code>Rule2</code> rule will disable whitespace
skipping. This will change <code>Rule2</code> to match the word <code>firstsecond</code>, but not
words <code>first second</code> with whitespaces in between.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Remember that whitespace handling modification will start immediately
after the previous match. In the above example, additional <code>/\s*/</code> is
given before the <code>Rule2</code> call to consume all whitespaces before trying
to match <code>Rule2</code>.</p>
</div>
</li>
<li>
<p><strong>ws</strong> - used to redefine what is considered to be a whitespaces on the rule
  level. textX by default treats space, tab and new-line as a whitespace
  characters. This can be changed globally during the meta-model instantiation
  (see <a href="../parser_config/#whitespace-handling">Whitespace handling</a>) or per rule
  using this modifier.</p>
<p>Example:</p>
<pre><code>Rule:
    'entity' name=ID /\s*/ call=Rule2;
Rule2[ws='\n']:
    'first' 'second';
</code></pre>
<p>In this example <code>Rule</code> will use the default parser behavior but the <code>Rule2</code>
will alter the white-space definition to be new-line only. This means that
the words <code>first</code> and <code>second</code> will get matched only if they are on separate
lines or in the same line but without other characters in between (even tabs
and spaces).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>As in the previous example, the modification will start immediately, so
if you want to consume preceding spaces you must do that explicitly, as
given with <code>/\s*/</code> in the :<code>Rule</code>.</p>
</div>
</li>
</ul>
<h2 id="grammar-comments">Grammar comments<a class="headerlink" href="#grammar-comments" title="Permanent link">&para;</a></h2>
<p>Syntax for comments inside a grammar is <code>//</code> for line comments and <code>/* ... */</code>
for block comments.</p>
<h2 id="language-comments">Language comments<a class="headerlink" href="#language-comments" title="Permanent link">&para;</a></h2>
<p>To support comments in your DSL use a special grammar rule <code>Comment</code>. textX will
try to match this rule in between each other normal grammar match (similarly to
the whitespace matching). If the match succeeds, the matched content will be
discarded.</p>
<p>For example, in the <a href="../tutorials/robot/">robot language example</a> comments are
defined like this:</p>
<pre><code>Comment:
  /\/\/.*$/
;
</code></pre>
<p>Which states that everything starting with <code>//</code> and continuing until the end of
line is a comment.</p>
<h2 id="grammar-modularization">Grammar modularization<a class="headerlink" href="#grammar-modularization" title="Permanent link">&para;</a></h2>
<p>Grammars can be defined in multiple files and than imported. Rules used in the
references are first searched for in the current file and then in the imported
files, in the order of the import.</p>
<p>Example:</p>
<pre><code>import scheme

Library:
  'library' name=Name '{'
    attributes*=LibraryAttribute

    scheme=Scheme

  '}'
;
</code></pre>
<p><code>Scheme</code> rule is defined in <code>scheme.tx</code> grammar file imported at the beginning.</p>
<p>Grammar files may be located in folders. In that case, dot notation is used.</p>
<p>Example:</p>
<pre><code>import component.types
</code></pre>
<p><code>types.tx</code> grammar is located in the <code>component</code> folder relatively to the
current grammar file.</p>
<p>If you want to override the default search order, you can specify a fully
qualified name of the rule using dot notation when giving the name of the
referring object.</p>
<p>Example:</p>
<pre><code>import component.types

MyRule:
  a = component.types.List
;

List:
  '[' values+=BASETYPE[','] ']'
;
</code></pre>
<p><code>List</code> from <code>component.types</code> is matched/instantiated and set to <code>a</code> attribute.</p>
<h2 id="inspecting-textx-grammars-programmatically">Inspecting textX grammars programmatically<a class="headerlink" href="#inspecting-textx-grammars-programmatically" title="Permanent link">&para;</a></h2>
<p>Since textX is a meta-language (a language for language definition) any textual
language can be specified using it, even <a href="https://github.com/textX/textX/blob/master/textx/textx.tx">textX grammar language
itself</a>.</p>
<p>This definition enable loading of textX grammar as a plain Python model which
can be further analyzed for various purposes. This can be used, e.g. for tooling
which need to analyze the grammar beyond of just syntactic and semantic checks
(e.g. syntax highlighting may analyze grammar to discover keywords that needs to
be colored).</p>
<p>To load grammar model first get the textX language meta-model with:</p>
<pre><code class="language-python">textx_mm = metamodel_for_language('textx')
</code></pre>
<p>and then call either <code>grammar_model_from_str</code> or <code>grammar_model_from_file</code>
method on this meta-model object:</p>
<pre><code>grammar_model = textx_mm.grammar_model_from_file(
    join(abspath(dirname(__file__)), 'pyflies.tx'))
</code></pre>
<p>Then investigate this model as you would do with any other model:</p>
<pre><code>assert len(grammar_model.imports_or_references) == 3
assert len(grammar_model.rules) == 45

str_matches = get_children_of_type(&quot;SimpleMatch&quot;, grammar_model)
...
</code></pre>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../metamodel/" class="btn btn-neutral float-right" title="Meta-model">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../tutorials/hello_world/" class="btn btn-neutral" title="Hello world"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
      <p>Copyright &copy; <a href="http://www.igordejanovic.net/">Igor DejanoviÄ‡</a>.</p>
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a href="https://github.com/textX/textX/" class="fa fa-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
        <span><a href="../tutorials/hello_world/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../metamodel/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../js/version-select.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
